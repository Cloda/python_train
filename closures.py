#  Все переменные - это ссылки на объекты
#  Замыкание - это функция внутри, которой есть ссылки на переменные, 
#			   были объявлены вне её тела(в окружающем коде)
#  Пользы в python никакой(((
a = 1
b = a
print(id(a))
print(id(b))
#  id(a) = id(b) , т.к. ссылаются на один объект, в данном случае 1


a = 2
print(b)
print(id(a))
print(id(b))
#  id(a) != id(b), т.к. b ссылается на страрый объект 1, а ссылается на новый объект 2


del(a, b)


a = []
b = a
a.append("asdf")
print(b)
#  ["asdf"] т.к. a и b ссылаются на один изменяемый объект


def f():
	x = 1
try:
	print(x)
except:
	print("Была ошибка")
def one():
	x = ['one', 'two']
	def inner():
		print(x)
		print(id(x))
	return inner
o = one()
print(o)
#  о будет функицией inner
o()
print(dir(o))
print(dir(o.__closure__))
print(dir(o.__closure__[0]))
print(dir(o.__closure__[0].cell_contents))
#  вернул список, который был определен внутри функции inner
a = id(o.__closure__[0].cell_contents)
print(a)
#  a = id(x), это значит что x стал доступен в глобальной зоне видимости переменных


a = o.__closure__[0].cell_contents
a.append("asdf")	#  добавили данных через глобальную облать видимости в локальную переменную 
print(a)
o()
#  o() = print(a)
#  это происходит так как ссылки на на x не убираются, 
#  поэтому x продолжает существовать. Убереться он только тогда,
#  когда ссылок на него не останется


























